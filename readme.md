+ 式微，式微！胡不归？
+ 不行了，不行了，你怎么还在写程序？

项目目的：如中文脚本 c++ 版一般用脚本直接调用动态库

有所简化，如对 linux 系统基础标准库 libstdc++ 的接口脚本由

```
模块“标准库”。

赋予“句柄”【私】以函数集
“libstdc++.so.6.0.13”、
“libstdc++.so.6”、
“libstdc++-libc6.1-1.so.2”、
“libstdc++.dylib”。

函数“格输出”以“printf”、‘句柄’、“i-c*”。
（……）
```
改为

```
模块“标准库”。

函数集
“libstdc++.so.6.0.13”、
“libstdc++.so.6”、
“libstdc++-libc6.1-1.so.2”、
“libstdc++.dylib”。

函数“格输出”以“printf”、“i-c*”。
（……）
```
（以上分拆为 zs2-l4-rust）

### 开三工鸟

```bash
$ git clone "https://github.com/zzzzzzzzzzz0/zhscript2-rust.git"
$ git clone "https://github.com/zzzzzzzzzzz0/zs2-l4-rust.git"
$ git clone "https://github.com/zzzzzzzzzzz0/l4-rust.git"
$ cd l4-rust
```

需要支持 asm 的 nightly 版才能编译

```bash
$ rustup override set nightly
```

```bash
$ cargo run src2/dl.zs
```

如果输出最终类似于

```
当前目录/zzzzzzzzzzz4/zzzzzzzzzzz/github/l4-rust
c 21 -2100000000 4200000000 string 3.567000
```

那么吾甚欣慰否则头痛吧

__（v0.7.30 突兀地就这么插了进来）你觉得下面代码运行后会出现什么？__

```
加载lib/clpars4。

赋予1宽、前出以6、2。
赋予解以调用‘命令行加回调’、、
	-、、0、下代码
		赋予层【上】以如果存在层【上】那么算术‘层’ + 1否则0。
		赋予檐宽以算术‘层’ + ‘1宽’ + ‘前出’。
		循环【‘檐宽’】先=了\换行。
		赋予檐宽以算术‘檐宽’ + 2。
		循环【‘檐宽’】先\了换行。
	上代码、
	、、1、下代码
		别名砖以参数0。
		赋予半宽以算术‘层’ + ‘1宽’。
		赋予墙高以算术3 + ‘层’ / 3、0。
		循环【‘墙高’】【砌】先
			循环【‘半宽’】【第】先
				如果‘砌’大于1
				并且‘砌’小于‘墙高’
				并且算术‘第’+ 2小于‘半宽’
				并且算术‘第’ % 3等于1那么
					“ ”
				否则先
					‘砖’
				了
			了。
			换行
		了。
	上代码。
显示调用‘命令行解析’、‘解’、
	-、*、-、@、-、&、-、$、-、%、-、+、-、#、-、#、-、#。
```

就是这样

```bash
$ cargo run src2/clpars-ta.zs

========\
\\\\\\\\\\
******
 *****
******
=========\
\\\\\\\\\\\
@@@@@@@
 @@ @@@
@@@@@@@
==========\
\\\\\\\\\\\\
&&&&&&&&
 && &&&&
 && &&&&
&&&&&&&&
===========\
\\\\\\\\\\\\\
$$$$$$$$$
 $$ $$$$$
 $$ $$$$$
$$$$$$$$$
============\
\\\\\\\\\\\\\\
%%%%%%%%%%
 %% %% %%%
 %% %% %%%
%%%%%%%%%%
=============\
\\\\\\\\\\\\\\\
+++++++++++
 ++ ++ ++++
 ++ ++ ++++
 ++ ++ ++++
+++++++++++
==============\
\\\\\\\\\\\\\\\\
############
 ## ## #####
 ## ## #####
 ## ## #####
############
===============\
\\\\\\\\\\\\\\\\\
#############
 ## ## ## ###
 ## ## ## ###
 ## ## ## ###
#############
================\
\\\\\\\\\\\\\\\\\\
##############
 ## ## ## ####
 ## ## ## ####
 ## ## ## ####
 ## ## ## ####
##############
```

对，九层宝塔，clpars4 本是用于命令行解析，而今越发觉得很适合格式化数据，中文脚本的目标“更简便、更活悦”

### 再

```bash
$ cargo run src2/gjk.zs
```

如果输出最终类似于

```
12345678901234567890.1234567890
一千二百三十四兆兆五千六百七十八兆九千零一十二亿三千四百五十六万七千八百九十点一二三四五六七八九零
12345678901234567890.12345
壹仟贰佰叁拾肆兆兆伍仟陆佰柒拾捌兆玖仟零壹拾贰亿叁仟肆佰伍拾陆万柒仟捌佰玖拾元零壹角贰分叁厘肆毫伍微
1234qWeR!@#$
1234QWER!@#$ "大写"
1234qwer!@#$ "小写"
!@#$QWER!@#$ "超大写"
1234qwer1234 "超小写"
1234QWeR!@#$ "大写" 4 5
1234qweR!@#$ "小写" 5 6
1@34qWeR!@#$ "超大写" 1 2
1234qWeR!@34 "超小写" -2
```

那么吾甚欣慰否则头痛吧。不管怎样，无论如何，src2/gjk.zs 的源码都是

```
加载lib/gjk4。

赋予食以12345678901234567890.1234567890。
显示‘食’换行先调用‘中文数字方法’、‘食’了换行。

赋予食以12345678901234567890.12345。
显示‘食’换行先调用‘大写金额方法’、‘食’了换行。

赋予食以1234qWeR!@#$。
显示‘食’换行。
定义测以下代码
	显示先调用‘‘参数1’方法’、‘食’、‘参数栈【2】’了“ ‘参数’”换行。
上代码。
测大写。
测小写。
测超大写。
测超小写。
测大写、4、5。
测小写、5、6。
测超大写、1、2。
测超小写、-2。
```
